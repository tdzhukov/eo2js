# eo2js

**eo2js** is a tool that's can be used to transform EO programs into JavaScript code, while preserving basic EOLANG principles (for example, no calculation is happening until the start of dataization process).

Consider the following simple EO program:

```
[a b] > app
  add. > @
    a
    b
```

That is how generated by eo2js JavaScript code for this object will look like:

```
class EOapp extends ElegantObject {
    
    constructor(kwargs={}) {
        super(kwargs);
        this.attr__self = this;
        this.attr__parent = new DataizationError();
        
        this.attr_a = new DataizationError();
        this.attr_b = new DataizationError();
        
        this.attributes = ["a", "b", ];
        
    }
    
    
    get attr__phi() {
        return (new Attribute((this.attr_a), "add", ).call(this.attr_b));
    }
    
    toString() {
        return `EOapp()`;
    }
}

Object.assign(EOapp.prototype, ApplicationMixin);
```

As we can see, code, that is written in `attr__phi()` getter, will be evaluated only when we will refer to it in the code. But it will be referred to only during the dataization process. In the implementation of the `attr__phi()` (which is used to denote a Ï†-attribute) we are taking `.add` attribute of `.a` free attribute of object `app` and then passing `app.b` to it as an argument. Passing object as an argument is implemented by `.call(arg)` method, which is added to classes via `ApplicationMixin` mixin. All of this is exactly the same process, that is happening in the original EO code during dataization.

So now we can instantiate object `EOapp` with arguments and start the dataization by the following line of code:

```
new EOapp().call(new ElegantNumber(11)).call(new ElegantNumber(31)).dataize();
```

The result of this dataization is `ElegantNumber(42)` (`ElegantNumber` is an atom that is being used to work with numbers).

## How to use

First, clone this repo to your local machine (you will need [Git](https://git-scm.com/book/en/v2/Getting-Started-Installing-Git) installed):

```bash
$ git clone https://github.com/tdzhukov/eo2js.git
```

After that, you can compile and run the code (you will need [Maven 3.3+](https://maven.apache.org/), [Java SDK 8+](https://www.java.com/en/download/) and [NPM 8.1.2+](https://www.npmjs.com/package/npm) installed) by running from the root directory:

```bash
$ npm run build -- sandbox
```

This script will run `eo2js-maven-plugin` configured in the `pom.xml` of this repository.

Files from `sandbox/eo` will be translated into JavaScript. Intermediary `*.xml` files will be generated in the `sandbox/target` directory (it will be created). Also, there will be `.js` files in `sandbox/target/generated-sources` folder. Feel free to analyze them: EO is parsed into XML by [eo-parser v0.29.3](https://mvnrepository.com/artifact/org.eolang/eo-parser), then translated to JavaScript.

To run tests, you just need to do this:

```
$ npm run build -- eo2js-runtime
$ npm test
```

## How it works
Firstly, EO source code is being parsed into XML using [eo-parser v0.29.3](https://mvnrepository.com/artifact/org.eolang/eo-parser). Secondly, XML file is being processed through a bunch of XSL transformations. In the repository they can be found [there](https://github.com/tdzhukov/eo2js/tree/main/eo2js-maven-plugin/src/main/resources/org.eolang.maven).

In the final JavaScript code each EO object is transformed into JavaScript class. Each class inherits from a base class `ElegantObject`, which provides `dataize()` method and some other functionality. Object's attributes are the properties of the corresponding class. If the objects has free attributes, it could be specified via `.call(arg)` method that's being added by `ApplicationMixin` mixin. Some of the used in final JavaScript code objects are atoms. Atoms are implemented separately and being imported into JavaScript code. You can find the implementation [here](https://github.com/tdzhukov/eo2js/tree/main/eo2js-runtime/atoms).

Process of XSLT consists of 2 stages: optimize and pre. Throughout the optimize stage XML is being restructured in such way that it can be transformed to JavaScript easier. In the pre stage there are transformations that adds some specific to JavaScript XML elements and attributes and, after all, completely transforms XML into JavaScript code.

Optimize stage consists of the following XSL transformations:

1) Default ParsingTrain XSLT pack (could be found [here](https://github.com/objectionary/eo/blob/58f4dbd9986c7dd1241d6444088d4f2249f7c368/eo-parser/src/main/java/org/eolang/parser/ParsingTrain.java#L58));
2) `optimize/globals-to-abstracts.xsl` turns global copies of abstract objects into new abstract objects;
3) `optimize/abstracts-float-up.xsl` -- abstracts that stay inside other abstracts are moving to the highest level (this and previous transformation are needed to make sure that all the abstracts will be turned into JavaScript classes. We will turn to classes only abstracts that stay on the highest level, because it's easier, and by that transformations we prepare XML to our next moves);
4) `optimize/fix-missed-names.xsl` and `optimize/fix-abstracts.xsl` -- fix errors that could arise through the previous two steps.

Pre stage consists of the following XSL transformations:

1) `pre/classes.xsl` -- XML elements `<o>` that are the abstract objects is being replaced by `<class>`;
2) `pre/attrs.xsl` -- objects' attributes is being marked by XML elements `<attr>` and `<free>` or `<bound>` (depends on its type);
3) `pre/varargs.xsl` -- objects, that can take an unlimited number of arguments, are being marked by `<varargs>` element;
4) `pre/arrays.xsl` and `pre/booleans.xsl` -- adding some special XML attributes to arrays, tuples and booleans;
5) `pre/data.xsl` -- adding XML attribute `@javascript-type` to objects that contain data. This attribute's value is the JavaScript atom's class name, that will ve used for the current object with data.

And the final XSLT in this stage is the biggest one. It replaces each `<class>` element with `<javascript>` element which contains plain-text JavaScript source code for this class. Code generation for the class begins from the constructor, where all the properties are being initialized. Then it proceeds to generation of the getters for bound attributes.

If bound attribute is a copy of some abstract object, then the new copy of this object is being created and its arguments are being applied via `.call(arg)` method. In case when argument is also a copy of an abstract object, which is quite a common case for EO programs, code generation is done in form of XSL template, which is applying recursively to the inner objects. Because of this, applying an argument, which is a copy with argument, which is also a copy with argument, which... and so on, is also working pretty well.

After that, Java code is processing the resulting XML file by concatenating all the `<javascript>` elements and adding some other lines like meta-information, imports, source EO code, storage initialization for the dataize once functionality and memory atom. Finally, it saves the code in `.js` file and after that generation is done!

## How to Contribute

Fork repository, make changes, send us a pull request.
We will review your changes and apply them to the `main` branch shortly,
provided they don't violate our quality standards. To avoid frustration,
before sending us your pull request please run full Maven build:

```bash
$ mvn clean install -Pqulice
```

You will need Maven 3.3+ and Java 8+.